//------------------------------------------------------------------------------
//     Данный модуль служит для пересчета  принятых
//     данных от гироскопического устройства
//     Автор: Щербаков Александр
//     дата создания: 13.09.2018
//
//------------------------------------------------------------------------------
#include "gyromeasure.h"
#include <QDebug>
#include <QDataStream>
#include <QtMath>

//-----------------------------------------------------------
// Назначение: десереализация принятого пакета
//-----------------------------------------------------------
QDataStream &operator>>(QDataStream &in, FastPacket &packet)
{
    in >> packet.Header;
    in >>packet.cnt    ;
    in >>packet.da1    ;
    in >>packet.da2    ;
    in >>packet.da3    ;
    in >>packet.dv1    ;
    in >>packet.dv2    ;
    in >>packet.dv3    ;
    in >>packet.Tmsk   ;
    in >>packet.CRC;
    return in;
}
//-----------------------------------------------------------
// Назначение: конструктор класса
//-----------------------------------------------------------
GyroMeasure::GyroMeasure(QObject *parent) : QObject(parent)
{
    countPacket=0;
    Slip=new SlipProtocol;
    connect(Slip,&SlipProtocol::outDecodeArray,
            this,&GyroMeasure::SortData);
    lstVal=new QList<QString>;
    lstName=new QList<QString>{
            tr("Заголовок"),tr("Число пакетов"),
            tr("dat1[град/час]"),tr("dat2[град/час]"),tr("dat3[град/час]"),
            tr("dvt1[м/с2]"),tr("dvt2[м/с2]"),tr("dvt3[м/с2]")
            ,tr("Время[сек]"),tr("Контр.сумма")};
    isAccumulateData=false;
    numMeasure=0;
    numPosition=0;
    this->summ=0;

}
//-----------------------------------------------------------
// Назначение:
//-----------------------------------------------------------
//void GyroMeasure::Measure(int num)
//{
//    static float SummAzimuth=0.;;
//    if(num && numMeasure<num )
//    {
//        numMeasure=num;
//        Azimuth=qRadiansToDegrees(static_cast<float>(atan2((da[0]-da[1]),(da[2]-da[3]))));
//        SummAzimuth+=Azimuth;
//        if(numMeasure>1){
//        meanValue=Azimuth/static_cast<float>(numMeasure);
    
//        maxValue>Azimuth?maxValue:maxValue=Azimuth;
    
//        minValue<Azimuth?minValue:minValue=Azimuth;
//        }
//        else{
//            meanValue=maxValue=minValue=Azimuth;

//        }
//    //TODO : пересчет СКО
//        da[0]=0;da[1]=0;da[2]=0;da[3]=0;
//        emit SendMeasureData(
//                    static_cast<QVariant>(Azimuth).toString(),
//                    static_cast<QVariant>(meanValue).toString(),
//                    static_cast<QVariant>(minValue).toString(),
//                    static_cast<QVariant>(maxValue).toString(),
//                    static_cast<QVariant>(sko).toString()
//                );
//    }
    
//}
//-----------------------------------------------------------
// Назначение: накопление данных
//-----------------------------------------------------------
//void GyroMeasure::Accumulate()
//{
//    static int position=0;
//    switch (position) {
//    case 0:
//        da[0]+=packet.da2;
//        position++;
//        break;
//    case 1:
//        da[1]+=packet.da2;
//        position++;
//        break;
//    case 2:
//        da[2]+=packet.da2;
//        position++;
//        break;
//    case 3:
//        da[3]+=packet.da2;
//        position=0;
//        break;
//    default: break;
//    }
//}
//-----------------------------------------------------------
// Назначение: прием данных
//-----------------------------------------------------------
void GyroMeasure::GetData(QByteArray inputArray)
{
    Slip->GetSlipByteArray(inputArray);

}
//-----------------------------------------------------------
// Назначение: сортировка принятых данных(занесение в
//             данных структуры)
//-----------------------------------------------------------
void GyroMeasure::SortData(QByteArray data)
{

    QDataStream stream(data);
    stream.setFloatingPointPrecision(QDataStream::SinglePrecision);
    stream.setByteOrder(QDataStream::LittleEndian);

    countPacket++;
    stream>>packet;
    

    FillOutList(packet);
    if(isAccumulateData)
        //this->Accumulate();
        summ+=packet.da2;
    
    emit outCountPacket(QVariant(countPacket).toString());
    emit SendDataToTable(lstVal,lstName);
    
}
//-----------------------------------------------------------
// Назначение: получение текущей позиции 
//-----------------------------------------------------------
//void GyroMeasure::GetPosition(int position)
//{
//    numPosition=position;
//}
//-----------------------------------------------------------
// Назначение: количество завершенных измерений 
//-----------------------------------------------------------
//void GyroMeasure::GetNumMeasure(int num)
//{
//    numMeasure=num;
//}
//-----------------------------------------------------------
// Назначение: управление признаком накопления данных 
//-----------------------------------------------------------
void GyroMeasure::AccumulateData()
{
    isAccumulateData=true;
}
//-----------------------------------------------------------
// Назначение: управление признаком накопления данных 
//-----------------------------------------------------------
void GyroMeasure::NoAccumulateData()
{
    isAccumulateData=false;
}
//-----------------------------------------------------------
// Назначение: заполнение данных в список
//             для табличного отображения в форме
//-----------------------------------------------------------
void GyroMeasure::FillOutList(FastPacket packet)
{
    lstVal->clear();
    ListAppend(lstVal,packet.Header);
    ListAppend(lstVal,packet.cnt);
    ListAppend(lstVal,packet.da1);
    ListAppend(lstVal,packet.da2);
    ListAppend(lstVal,packet.da3);
    ListAppend(lstVal,packet.dv1);
    ListAppend(lstVal,packet.dv2);
    ListAppend(lstVal,packet.dv3);
    ListAppend(lstVal,packet.Tmsk);
    ListAppend(lstVal,packet.CRC);
}
//-----------------------------------------------------------
// Назначение: занесение разнотипных данных в строковый
//            список
//-----------------------------------------------------------
inline void GyroMeasure::ListAppend(QList<QString> *lst, QVariant val)
{
    lst->append(val.toString());
}


